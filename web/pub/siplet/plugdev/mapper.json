{"name":"Mapper","version":4,"requires":"3.2.0","mxp":"","triggers":[],"menus":{"Help":[{"n":"Mapper Plugin","a":"win.sendPlugin('Mapper','Help');"}]},"aliases":[{"name":"GoMap","regex":false,"replace":"","pattern":"/map","action":"win.sendPlugin('Mapper','{\"type\":\"map\"}');"}],"timers":[],"code":"const mapper = win.mapper;\n\nlet cofudlet = win.cofudlet || {};\ncofudlet.map = cofudlet.map || {};\nconst map = cofudlet.map;\nvar cleanUrl = window.url;\nif(cleanUrl.indexOf('://')>0)\n\tcleanUrl = cleanUrl.split('://')[1];\nif(cleanUrl.indexOf('/')>0)\n\tcleanUrl = cleanUrl.split('/')[0];\ncleanUrl = cleanUrl.replace(/[^a-zA-Z0-9]/g,'_');\nconst mapPath = '/Mapper/'+cleanUrl+'.json';\n\nmap.terrainColors = \n{\n\t// Admire the colors at https://wiki.mudlet.org/w/Manual:Lua_Functions#setCustomEnvColor - they're also configurable by the end user.\n\tcity: 263,\n\twoods: 258,\n\trocky: 272,\n\tplains: 266,\n\tunderwater: 260,\n\tair: 270,\n\twatersurface: 268,\n\tjungle: 262,\n\tswamp: 259,\n\tdesert: 267,\n\thills: 261,\n\tmountains: 269,\n\tspaceport: 271,\n\tseaport: 271,\n\n\t// indoors\n\tstone: 263,\n\twooden: 259,\n\tcave: 272,\n\tmagic: 269,\n\tin_underwater: 260,\n\tgap: 271,\n\tcavelakesurface: 268,\n\tmetal: 272,\n\tinnerseaport: 271,\n\tcaveseaport: 271,\n};\n\nmap.normalizedDirections = \n{\n\tN: 'north',\n\tE: 'east',\n\tS: 'south',\n\tW: 'west',\n\tU: 'up',\n\tD: 'down',\n\tn: 'north',\n\te: 'east',\n\ts: 'south',\n\tw: 'west',\n\tu: 'up',\n\td: 'down',\n\tnorth: 'north',\n\teast: 'east',\n\tsouth: 'south',\n\twest: 'west',\n\tup: 'up',\n\tdown: 'down',\n\tnw: 'northwest',\n\tne: 'northeast',\n\tsw: 'southwest',\n\tse: 'southeast',\n\tnorthwest: 'northwest',\n\tnortheast: 'northeast',\n\tsouthwest: 'southwest',\n\tsoutheast: 'southeast',\n};\n\nmap.shortDirections = \n{\n\tnorth: 'n',\n\teast: 'e',\n\tsouth: 's',\n\twest: 'w',\n\tup: 'u',\n\tdown: 'd',\n\tnorthwest: 'nw',\n\tnortheast: 'ne',\n\tsouthwest: 'sw',\n\tsoutheast: 'se',\n};\n\nfunction stripColors(str) \n{\n\tstr = str.replace(/\\^[MRGYBPCWkrgybpcw?]/g, \"\");\n\treturn str.replace(/\\^#\\d{3}/g, \"\");\n}\n\nfunction trim(s) \n{\n\tconst match = s.match(/^\\s*(.*?)\\s*$/);\n\treturn match ? match[1] : \"\";\n}\n\nmap.currentArea = function() \n{\n\tconst areaName = gmcp.room.info.zone;\n\treturn getAreaTable()[areaName];\n};\n\nmap.isInstanced = function() \n{\n\treturn !!String(gmcp.room.info.zone).match(/ of Mystery/);\n};\n\nconst currentArea = () => map.currentArea();\n\n// visitRoom returns null to continue search, or a value to signal the end of search (like path to desired room).\n// visitExit returns true if we should stop BFSing after this exit.\nfunction search(here, visitRoom, visitExit, bypassLocks, inArea, breadthFirst) \n{\n\tconst area1 = mapper.getRoomArea(mapper.getPlayerRoom());\n\tconst visited = {};\n\tconst roomq = [];\n\troomq.push(here);  // pushRight equivalent\n\twhile (roomq.length > 0) \n\t{\n\t\tconst room = breadthFirst ? roomq.shift() : roomq.pop();  // popLeft = shift, popRight = pop\n\t\tif (visited[room] === undefined) \n\t\t{\n\t\t\tconst ex = mapper.getRoomExits(room);\n\t\t\tfor (let [exDir, exTgt] of Object.entries(ex)) \n\t\t\t{\n\t\t\t\tif ((bypassLocks || !hasExitLock(room, exDir)) && (!inArea || mapper.getRoomArea(exTgt) === -1 || area1 === mapper.getRoomArea(exTgt)) /*&& not isHardLocked(room, exDir) */) \n\t\t\t\t{\n\t\t\t\t\t// TODO: add options to path through swim-only rooms, etc\n\t\t\t\t\t/*\n\t\t\t\t\t  if (true && ex[exDir].get('data', {}).get('swim')) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t  }\n\t\t\t\t\t  if (true && ex[exDir].get('data', {}).get('crawl')) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t  }\n\t\t\t\t\t  if (true && ex[exDir].get('data', {}).get('climb')) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t  }\n\t\t\t\t\t  if (true && ex[exDir].get('data', {}).get('fly')) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t  }\n\t\t\t\t\t*/\n\t\t\t\t\tif (!visitExit(room, exDir, exTgt))\n\t\t\t\t\t\troomq.push(exTgt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst res = visitRoom(room);\n\t\t\tif (res !== null)\n\t\t\t\treturn res;\n\t\t\tvisited[room] = true;\n\t\t}\n\t}\n}\n\nmap.bfs = function(here, visitRoom, visitExit, bypassLocks, inArea) \n{\n\treturn search(here, visitRoom, visitExit, bypassLocks, inArea, true);\n};\n\nmap.dfs = function(here, visitRoom, visitExit, bypassLocks, inArea) \n{\n\treturn search(here, visitRoom, visitExit, bypassLocks, inArea, false);\n};\n\nfunction runifyDirs(directions) \n{\n\tlet count = 1;\n\tlet out = \"\";\n\tlet first = true;\n\tfor (let i = 1; i < directions.length; i++) \n\t{  // 1-based, but JS arrays 0-based\n\t\tif (directions[i-1] === directions[i])\n\t\t\tcount++;\n\t\telse \n\t\t{\n\t\t\tif (first)\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\tout += ' ';\n\t\t\tout += (count === 1 ? \"\" : count) + directions[i-1];\n\t\t\tcount = 1;\n\t\t}\n\t}\n\tif(!first)\n\t\tout += ' ';\n\tout += (count === 1 ? \"\" : count) + directions[directions.length - 1];\n\treturn out;\n}\n\nconsole.assert(runifyDirs(['e']) === 'e');\nconsole.assert(runifyDirs(['e', 'e']) === '2e');\nconsole.assert(runifyDirs(['n', 'e', 'e']) === 'n 2e');\nconsole.assert(runifyDirs(['e', 'e', 'n']) === '2e n');\n\ncofudlet.map.assemble = function(dirs, mode) \n{\n\tconst directions = [];  // streak of non-special exits\n\tconst out = [];\n\tfor(let compoundDir of dirs) \n\t{\n\t\tconst splitDirs = compoundDir.split(';;');\n\t\tfor (let dir of splitDirs) \n\t\t{\n\t\t\tif(dir === 'down') \n\t\t\t\tdir = 'd';\n\t\t\telse \n\t\t\tif (dir === 'up') \n\t\t\t\tdir = 'u';\n\t\t\tif(!map.normalizedDirections[dir]) \n\t\t\t{\n\t\t\t\tif (directions.length > 0)\n\t\t\t\t\tout.push(mode + ' ' + runifyDirs(directions));\n\t\t\t\tout.push(dir);\n\t\t\t\tdirections.length = 0;  // clear\n\t\t\t} \n\t\t\telse\n\t\t\t\tdirections.push(dir);\n\t\t}\n\t}\n\tif(directions.length > 0)\n\t\tout.push(mode + ' ' + runifyDirs(directions));\n\treturn out.join(';;');\n};\n\nconsole.assert(cofudlet.map.assemble(['e'], 'go') === 'go e');\nconsole.assert(cofudlet.map.assemble(['e', 'e'], 'go') === 'go 2e');\nconsole.assert(cofudlet.map.assemble(['n', 'e', 'e'], 'go') === 'go n 2e');\nconsole.assert(cofudlet.map.assemble(['e', 'e', 'n'], 'go') === 'go 2e n');\n\nconsole.assert(cofudlet.map.assemble(['open e;;e', 'e'], 'go') === 'open e;;go 2e');\nconsole.assert(cofudlet.map.assemble(['open e;;e', 'e', 'e'], 'go') === 'open e;;go 3e');\nconsole.assert(cofudlet.map.assemble(['open e;;e', 'n', 'e', 'e'], 'go') === 'open e;;go e n 2e');\nconsole.assert(cofudlet.map.assemble(['open e;;e', 'e', 'e', 'n'], 'go') === 'open e;;go 3e n');\n\nconsole.assert(cofudlet.map.assemble(['e', 'open e;;e', 'n'], 'go') === 'go e;;open e;;go e n');\nconsole.assert(cofudlet.map.assemble(['e', 'e', 'open e;;e', 'n'], 'go') === 'go 2e;;open e;;go e n');\n\n// TODO: implement swim/crawl/fly/climb locks.\n// TODO: implement level locks.\nfunction doSpeedWalk() \n{\n\tconst goCmd = map.goCmd || \"go\";\n\tsend(cofudlet.map.assemble(speedWalkDir, goCmd));\n}\n\ncofudlet.map.oppositeDirections = \n{\n\tnorth: \"south\",\n\teast: \"west\",\n\tsouth: \"north\",\n\twest: \"east\",\n\tup: \"down\",\n\tdown: \"up\",\n\tnorthwest: \"southeast\",\n\tnortheast: \"southwest\",\n\tsouthwest: \"northeast\",\n\tsoutheast: \"southwest\",  // Note: Likely typo in original; should be \"northwest\"?\n};\n\nfunction targetToCid(there) \n{\n\tconst bookmarks = JSON.parse(getMapUserData(\"bookmarks\") || \"{}\");\n\tif (bookmarks[there]) \n\t{\n\t\tthere = bookmarks[there];\n\t\tconsole.info(`Map: going to bookmark ${parameter} Cid ${there}`);  // Assuming 'parameter' is a global or replace with 'there'\n\t\treturn there;\n\t}\n\n\tlet areaId = getAreaTable()[there];\n\tif(areaId) \n\t{\n\t\tthere = getAreaUserData(areaId, \"startRoomCid\");\n\t\tconsole.info(`Map: going to area ${parameter}, start room ${there}`);\n\t\treturn there;\n\t}\n\n\tareaId = getAreaTable()[there.replace(/'/g, '`')];\n\tif(areaId) \n\t{\n\t\tthere = getAreaUserData(areaId, \"startRoomCid\");\n\t\tconsole.info(`Map: going to area ${parameter}, start room ${there}`);\n\t\treturn there;\n\t}\n\n\tif(!isNaN(there)) \n\t{\n\t\tconst cid = mapper.getRoomIDbyHash(there);\n\t\tif((cid != -1) && (!mapper.roomExists(cid)))\n\t\t\tcid = -1;\n\t\tif(cid !== -1) \n\t\t{\n\t\t\tconsole.info(`Map: going to ${mapper.getRoomUserData(cid, 'id')} ${mapper.getRoomName(cid)}`);\n\t\t\treturn cid;\n\t\t}\n\n\t\tconst num = mapper.getRoomHashByID(there);\n\t\tif(num) \n\t\t{\n\t\t\tconsole.info(`Map: going to ${mapper.getRoomUserData(there, 'id')} ${mapper.getRoomName(there)}`);\n\t\t\treturn there;\n\t\t}\n\t}\n\n\tif(there.match(/.+#\\d+$/)) \n\t{\n\t\tconst areaName = there.replace(/#\\d+$/, \"\");\n\t\tareaId = getAreaTable()[areaName];\n\t\tconst areaRooms = getAreaRooms(areaId);\n\t\tfor (let cid in areaRooms) \n\t\t{\n\t\t\tif(mapper.getRoomUserData(cid, \"id\") === there) \n\t\t\t{\n\t\t\t\tconsole.info(`Map: going to area ${areaId}, ${areaName} room ${there}`);\n\t\t\t\treturn cid;\n\t\t\t}\n\t\t}\n\t\tconsole.info(`Map: couldn't find room ${there} in area ${areaId} ${areaName}`);\n\t}\n\n\tconst allRooms = mapper.getRooms();  // Assuming {cid: name}\n\tconst exactMatches = [];\n\tconst upperThere = there.toUpperCase();\n\tfor(let [cid, rname] of Object.entries(allRooms)) \n\t{\n\t\tif (rname.toUpperCase().replace(/`/g, \"'\") === upperThere.replace(/`/g, \"'\"))\n\t\t\texactMatches.push(cid);\n\t}\n\n\tif(exactMatches.length === 1) \n\t{\n\t\tconsole.info(`Map: going to room ${there}, Cid ${exactMatches[0]}`);\n\t\treturn exactMatches[0];\n\t} \n\telse \n\tif(exactMatches.length > 1) \n\t{\n\t\tconsole.info(`Map: TODO implement room selection. Meanwhile, \\`map go\\` to one of these rooms:`);\n\t\tconsole.console.info(exactMatches);\n\t\treturn;\n\t}\n\n\tconst fuzzyMatches = [];\n\tfor(let [cid, rname] of Object.entries(allRooms)) \n\t{\n\t\tconst gsubbedName = rname.toUpperCase().replace(/`/g, \"'\");\n\t\tconst gsubbedThere = upperThere.replace(/`/g, \"'\");\n\t\tif (gsubbedName.includes(gsubbedThere))\n\t\t\tfuzzyMatches.push({cid: cid, name: rname});\n\t}\n\tif(fuzzyMatches.length === 1) \n\t{\n\t\tconsole.info(`Map: going to room ${fuzzyMatches[0].cid} ${fuzzyMatches[0].name}`);\n\t\treturn fuzzyMatches[0].cid;\n\t} \n\telse \n\tif(fuzzyMatches.length > 1) \n\t{\n\t\tconsole.info(`Map: TODO implement room selection. Meanwhile, \\`map go\\` to one of these rooms:`);\n\t\tconsole.console.info(fuzzyMatches);\n\t\treturn;\n\t}\n\tconsole.info(`Map: Room not found: ${parameter}`);\n}\n\nfunction goImpl(dest) \n{\n\tif(!dest) \n\t\treturn;\n\tif(getPlayerRoom() === parseInt(dest))\n\t\tconsole.info(\"Map: already there!\");\n\telse \n\t{\n\t\tconst [ok, err] = gotoRoom(dest);  // Assuming gotoRoom returns [bool, string]\n\t\tif (!ok)\n\t\t\tconsole.info(`Map: ${err}`);\n\t}\n}\n\n// As a weird side effect, these aliases also change what double-click on the graphical map does.\ncofudlet.map.go = function(to) \n{\n\tmap.goCmd = \"go\";\n\tgoImpl(targetToCid(to));\n};\n\ncofudlet.map.run = function(to) \n{\n\tmap.goCmd = \"run\";\n\tgoImpl(targetToCid(to));\n};\n\ncofudlet.map.path = function(to) \n{\n\tconst toCid = targetToCid(to);\n\tif (getPath(getPlayerRoom(), toCid))\n\t\tconsole.info(cofudlet.map.assemble(speedWalkDir, 'go'));\n\telse\n\t\tconsole.info(`No path found from ${getPlayerRoom()} to ${to}`);\n};\n\ncofudlet.map.cover = function(noSwimNoFly, excludedRooms) \n{\n\tconst here = mapper.getPlayerRoom();\n\tconst area1 = mapper.getRoomArea(mapper.getPlayerRoom());\n\tconst roomsList = [];\n\tconst roomsSet = {};\n\n\tfunction visitExit(room, exDir, tgt) \n\t{\n\t\treturn (excludedRooms || {})[tgt];\n\t}\n\n\tfunction visitRoom(room) \n\t{\n\t\tif (!roomsSet[room]) \n\t\t{\n\t\t\tconst terrain = mapper.getRoomUserData(room, \"terrain\");\n\t\t\tif (noSwimNoFly && (terrain === \"underwater\" || terrain === \"watersurface\" || terrain === \"in_underwater\" || terrain === \"cavelakesurface\"\n\t\t\t\t|| terrain === \"air\" || terrain === \"gap\"))\n\t\t\t\treturn;\n\t\t\troomsSet[room] = true;\n\t\t\troomsList.push(room);\n\t\t}\n\t}\n\tmap.dfs(here, visitRoom, visitExit, false, true);\n\treturn roomsList;\n};\n\nvar gmcp = {};\n\nfunction updateCoords(coords, direction) \n{\n\tswitch(direction)\n\t{\n\t\tcase \"north\": coords.y -= 1; break;\n\t\tcase \"east\": coords.x += 1; break;\n\t\tcase \"south\": coords.y += 1; break;\n\t\tcase \"west\": coords.x -= 1; break;\n\t\tcase \"up\": coords.z += 1; break;\n\t\tcase \"down\": coords.z -= 1; break;\n\t\tcase \"northeast\": coords.y -= 1; coords.x += 1; break;\n\t\tcase \"northwest\": coords.y -= 1; coords.x -= 1; break;\n\t\tcase \"southeast\": coords.y += 1; coords.x += 1; break;\n\t\tcase \"southwest\": coords.y += 1; coords.x -= 1; break;\n\t\tdefault: return null;\n\t}\n\treturn coords;\n}\n\nfunction getDirectionBetweenRooms(fromId, toId) \n{\n\tconst exits = mapper.getRoomExits(fromId);\n\tfor (let [dir, tgt] of Object.entries(exits)) \n\t{\n\t\tif (tgt === toId)\n\t\t\treturn dir;\n\t}\n}\n\nmap.setCoords = function(fromId, toId, dir) \n{\n\tlet prevCoords = {x: 0, y: 0, z: 0};\n\t[prevCoords.x, prevCoords.y, prevCoords.z] = mapper.getRoomCoordinates(fromId);\n\t// console.info(`Room prevCoords: ${prevCoords.x} ${prevCoords.y} ${prevCoords.z}`)\n\tconst nDir = map.normalizedDirections[String(dir).toLowerCase()];\n\tlet coords = updateCoords({...prevCoords}, nDir);\n\t// console.info(`Map debug: checking for collisions at area ${getRoomArea(fromId)}, room ${toId}: ${coords.x} ${coords.y} ${coords.z}`)\n\tlet collisions = mapper.getRoomsByPosition(mapper.getRoomArea(fromId), coords.x, coords.y, coords.z);\n\t// idempotency\n\tfor (let rid of collisions) \n\t{\n\t\tif (rid === toId)\n\t\t\treturn;\n\t}\n\n\tif (collisions.length > 0) \n\t{\n\t\tlet direction = getDirectionBetweenRooms(fromId, toId);\n\t\tconsole.info(`Map: Collision detected. Shifting rooms to fit this one. Direction: ${direction}`);\n\t\tconst areaRooms = mapper.getAreaRooms(mapper.getRoomArea(fromId));\n\t\tfor (let cid in areaRooms) \n\t\t{\n\t\t\tif (cid !== fromId) \n\t\t\t{\n\t\t\t\tlet [shiftX, shiftY, shiftZ] = mapper.getRoomCoordinates(cid);\n\t\t\t\tif (direction === 'down' && shiftZ <= coords.z) \n\t\t\t\t\tmapper.setRoomCoordinates(cid, shiftX, shiftY, shiftZ - 1);\n\t\t\t\telse \n\t\t\t\tif(direction === 'up' && shiftX >= coords.z) \n\t\t\t\t\tmapper.setRoomCoordinates(cid, shiftX, shiftY, shiftZ + 1);\n\t\t\t\telse \n\t\t\t\tif(shiftZ === coords.z) \n\t\t\t\t{\n\t\t\t\t\tif(direction === 'north' && shiftY >= coords.y) \n\t\t\t\t\t\tmapper.setRoomCoordinates(cid, shiftX, shiftY + 1, shiftZ);\n\t\t\t\t\telse \n\t\t\t\t\tif(direction === 'south' && shiftY <= coords.y) \n\t\t\t\t\t\tmapper.setRoomCoordinates(cid, shiftX, shiftY - 1, shiftZ);\n\t\t\t\t\telse \n\t\t\t\t\tif(direction === 'west' && shiftX <= coords.x) \n\t\t\t\t\t\tmapper.setRoomCoordinates(cid, shiftX - 1, shiftY, shiftZ);\n\t\t\t\t\telse \n\t\t\t\t\tif(direction === 'east' && shiftX >= coords.x) \n\t\t\t\t\t\tmapper.setRoomCoordinates(cid, shiftX + 1, shiftY, shiftZ);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// console.info(`Room ${toId} coords: ${coords.x} ${coords.y} ${coords.z}`)\n\tmapper.setRoomCoordinates(toId, coords.x, coords.y, coords.z);\n}\n\nfunction abortMapping() \n{\n\tmap.mapping = false;\n}\n\nfunction maybeAddArea(startRoom) \n{\n\tconst areaName = gmcp.room.info.zone;\n\tlet area = mapper.getAreaTable()[areaName];\n\tif (area === undefined) \n\t{\n\t\tarea = mapper.addAreaName(areaName);\n\t\tif (startRoom !== -1)\n\t\t\tmapper.getAreaUserData(area, \"startRoomCid\", startRoom);\n\t\tconsole.info(`Map: New area ${area}: ${areaName}, startRoom=${startRoom}`);\n\t\treturn [area, true];\n\t}\n\treturn [area, false];\n}\n\nfunction getHighestCoord(areaId) \n{\n\tconst rooms = mapper.getAreaRooms(areaId);\n\tlet [_, __, maxZ] = mapper.getRoomCoordinates(rooms[0]);\n\tfor (let cid in rooms) \n\t{\n\t\tlet [x, y, z] = mapper.getRoomCoordinates(cid);\n\t\tif (z > maxZ)\n\t\t\tmaxZ = z;\n\t}\n\treturn maxZ;\n}\n\n// Mazes\n// ~~~~~\n//\n// There are at least 4 kinds of mazes:\n// 1. fully connected blocks of rooms (every room, except edges, has 4 doors leading to all adjacent rooms): Goblin Mountains#24#(x, y)\n// 2. sparsely connected rooms (rooms are connected to adjacent rooms, but it's more difficult to find a way through corridors): Orthindar#214#(x, y), Medley Orchard's storyquest mazes\n// For all cases, track exits - if exits have changed at all (which will never trigger for case 1), then remove & rediscover all exits in the maze.\nconst mazePattern = /^[^#]+#(\\d+)#\\((\\d+),(\\d+)\\)$/;\nfunction isMaze(roomID) \n{\n\tconst match = String(roomID).match(mazePattern);\n\tif (match)\n\t\treturn [match[1], parseInt(match[2]), parseInt(match[3])];\n}\n\n// lua for _, cid in pairs(getAreaRooms(getRoomArea(getPlayerRoom()))) do local id = getRoomUserData(cid, \"id\"); console.info(f\"{cid} {id}\") end\nfunction tryCalculateMazeCoordinates(roomID, exitID) \n{\n\t// CoffeeMUD mazes are described with just one room ID + coords: Sewers#7019#(9,5)\n\tlet [_, __, thisX, thisY] = String(roomID).match(/^[^#]+#\\d+#\\((\\d+),(\\d+)\\)$/ || []) || [null, null, null, null];\n\t// console.info(\"TODO calculate mazy coordinates\")\n\treturn !!String(roomID).match(/^[^#]+#\\d+#\\(\\d+,\\d+\\)$/);\n}\n\n// Incomplete. It might happen that we walk through half the maze, which randomly happens to have the same\n// layout like last time, until finally hitting a room which we retain, but delete the rest. Instead,\n// we should also retain the path traversed so far - yet that's too much of a hassle.\nfunction deleteAllExitsFromThisMazeExcept(cid, niceId) \n{\n\tconst result = isMaze(niceId);\n\tif (!result) \n\t\treturn;\n\tconst [mazeId, x, y] = result;\n\tconst areaRooms = mapper.getAreaRooms(mapper.getRoomArea(cid));\n\tfor(let rid in areaRooms) \n\t{\n\t\tconst niceId2 = mapper.getRoomUserData(rid, \"id\");\n\t\tconst result2 = isMaze(niceId2);\n\t\tif(result2) \n\t\t{\n\t\t\tconst [mazeId2, x2, y2] = result2;\n\t\t\tif(mazeId2 === mazeId && rid !== cid) \n\t\t\t{\n\t\t\t\tconsole.info(`Removing exits from maze: ${niceId2}`);\n\t\t\t\tconst exits = mapper.getRoomExits(rid);\n\t\t\t\tfor (let dir in exits)\n\t\t\t\t\tmapper.setExit(rid, -1, dir);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// TODO: split and clean up\nfunction onGmcpRoomInfo() \n{\n\tconst num = gmcp.room.info.num;\n\tlet roomID = mapper.getRoomIdbyHash(num);\n\tif ((roomID != -1) && (!mapper.roomExists(roomID)))\n\t\troomID = -1;\n\n\tconst niceId = gmcp.room.info.id;\n\n\tlet [areaId, newArea] = maybeAddArea(roomID);\n\tif(roomID === -1 && !newArea) \n\t{\n\t\tconsole.info(`Map: teleported. Resetting coordinates to highest+100.`);\n\t\tlet z = getHighestCoord(areaId);\n\t\troomID = mapper.createRoomId();\n\t\tmapper.addRoom(roomID, areaId);\n\t\tmapper.setRoomIdByHash(roomID, num);\n\n\t\tlet positioned = false;\n\t\tfor(let [exitDir, targetNum] of Object.entries(gmcp.room.info.exits)) \n\t\t{\n\t\t\tlet targetID = mapper.getRoomIdbyHash(targetNum);\n\t\t\tif(targetID != -1 && mapper.roomExists(targetID)) \n\t\t\t{\n\t\t\t\tconst nDir = map.normalizedDirections[String(exitDir).toLowerCase()];\n\t\t\t\tconst oppDir = cofudlet.map.oppositeDirections[nDir];\n\t\t\t\tif(oppDir) \n\t\t\t\t{  // cardinal/reversible\n\t\t\t\t\tlet prevCoords = {x: 0, y: 0, z: 0};\n\t\t\t\t\t[prevCoords.x, prevCoords.y, prevCoords.z] = mapper.getRoomCoordinates(targetID);\n\t\t\t\t\tlet coords = updateCoords({...prevCoords}, oppDir);\n\t\t\t\t\tlet collisions = mapper.getRoomsByPosition(areaId, coords.x, coords.y, coords.z);\n\t\t\t\t\tif(collisions.length > 0) \n\t\t\t\t\t{\n\t\t\t\t\t\tconsole.info(`Map: Collision detected on reverse. Shifting rooms to fit this one. Direction: ${oppDir}`);\n\t\t\t\t\t\tconst areaRooms = mapper.getAreaRooms(areaId);\n\t\t\t\t\t\tfor (let cid of areaRooms) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (cid !== roomID) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlet [shiftX, shiftY, shiftZ] = mapper.getRoomCoordinates(cid);\n\t\t\t\t\t\t\t\tif (oppDir === 'down' && shiftZ <= coords.z) \n\t\t\t\t\t\t\t\t\tmapper.setRoomCoordinates(cid, shiftX, shiftY, shiftZ - 1);\n\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\tif(oppDir === 'up' && shiftZ >= coords.z) \n\t\t\t\t\t\t\t\t\tmapper.setRoomCoordinates(cid, shiftX, shiftY, shiftZ + 1);\n\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\tif(shiftZ === coords.z) {\n\t\t\t\t\t\t\t\t\tif(oppDir === 'north' && shiftY >= coords.y) \n\t\t\t\t\t\t\t\t\t\tmapper.setRoomCoordinates(cid, shiftX, shiftY + 1, shiftZ);\n\t\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\tif(oppDir === 'south' && shiftY <= coords.y) \n\t\t\t\t\t\t\t\t\t\tmapper.setRoomCoordinates(cid, shiftX, shiftY - 1, shiftZ);\n\t\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\tif(oppDir === 'west' && shiftX <= coords.x) \n\t\t\t\t\t\t\t\t\t\tmapper.setRoomCoordinates(cid, shiftX - 1, shiftY, shiftZ);\n\t\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\tif(oppDir === 'east' && shiftX >= coords.x) \n\t\t\t\t\t\t\t\t\t\tmapper.setRoomCoordinates(cid, shiftX + 1, shiftY, shiftZ);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmapper.setRoomCoordinates(roomID, coords.x, coords.y, coords.z);\n\t\t\t\t\tpositioned = true;\n\t\t\t\t\tbreak;  // use first reverse found\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!positioned)\n\t\t\tmapper.setRoomCoordinates(roomID, 0, 0, z + 100);\n\t} \n\tif(roomID === -1 && newArea) \n\t{\n\t\troomID = mapper.createRoomId();\n\t\tmapper.addRoom(roomID, areaId);\n\t\tmapper.setRoomIdByHash(roomID, num);\n\t\tmapper.setAreaUserData(areaId, \"startRoomCid\", roomID);\n\t\tconsole.info(`Map: backfilled missing area ${areaId} ${gmcp.room.info.zone} start room to ${roomID}`);\n\t}\n\n\tif(newArea)\n\t\tmapper.setRoomCoordinates(roomID, 0, 0, 0);\n\n\t// Normally this would go into the \"Things that never change\" section, but my imported maps lack IDs :(\n\t// TODO: map all the IDs, then move this line there.\n\tmapper.setRoomUserData(roomID, \"id\", niceId);\n\n\t// TODO: estimate move cost by moves lost (what about flight, mounts, etc?)\n\n\t// Things that might change: when you visit a previously hinted-at room,\n\t// its exits get populated\n\tfor(let [exitDir, targetNum] of Object.entries(gmcp.room.info.exits)) \n\t{\n\t\tlet exitID = mapper.getRoomIdbyHash(targetNum);\n\t\tif ((exitID != -1) && (!mapper.roomExists(exitID)))\n\t\t\texitID = -1;\n\t\t// console.info(`Map: exit stub towards ${exitDir}`)\n\n\t\tif(exitID === -1) \n\t\t{\n\t\t\texitID = mapper.createRoomId();\n\t\t\tmapper.addRoom(exitID, areaId);\n\t\t\t//setTimeout(function() { raiseEvent('cofudlet.onNewRoom', exitID); }, 0);\n\t\t\tmapper.setRoomIdByHash(exitID, targetNum);\n\t\t\tif (exitDir === \"V\")\n\t\t\t\tmapper.addSpecialExit(roomID, exitID, \"enter there\");\n\t\t\telse\n\t\t\t\tmapper.setExit(roomID, exitID, exitDir);\n\n\t\t\tmap.setCoords(roomID, exitID, exitDir);\n\t\t\tmapper.setRoomArea(exitID, areaId);\n\t\t} \n\t\telse \n\t\t{\n\t\t\t// console.info(`Not populating already seen exit from ${roomID} towards ${exitDir} to ${exitID}, coords from ${coords(roomID)} to ${coords(exitID)}`)\n\t\t\t// tryCalculateMazeCoordinates(roomID, exitID)\n\t\t\t// Partially connected mazes lose some exits every now and then. If exits disappear for this room, remove them for the whole maze - it's probably better to rediscover the whole maze rather than speedwalk through missing exits.\n\t\t\t// CoffeeMUD's exits don't normally disappear, not even secret exits.\n\t\t\t// This means we can just prune any missing exits regardless of whether they're mazy.\n\t\t\tlet found = false;\n\t\t\tconst normalizedDir = map.normalizedDirections[exitDir];\n\t\t\tconst roomExits = mapper.getRoomExits(roomID);\n\t\t\tfor(let [mapDir, mapTgt] of Object.entries(roomExits)) \n\t\t\t{\n\t\t\t\tif(map.normalizedDirections[mapDir] === normalizedDir) \n\t\t\t\t{\n\t\t\t\t\tfound = true;\n\t\t\t\t\tif (mapTgt !== exitID) \n\t\t\t\t\t{\n\t\t\t\t\t\tconsole.info(`Exit from ${roomID} ${mapDir}ward to ${mapTgt} reconnected to ${exitID}`);\n\t\t\t\t\t\tmapper.setExit(roomID, exitID, mapDir);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!found) \n\t\t\t{\n\t\t\t\tif (mapper.getRoomUserData(roomID, \"terrain\") !== \"\")\n\t\t\t\t\tconsole.info(`Existing room got a new exit from ${roomID} ${exitDir}ward to ${exitID}`);\n\t\t\t\tmapper.setExit(roomID, exitID, exitDir);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Prune disappeared exits\n\tconst roomExits = mapper.getRoomExits(roomID);\n\tfor(let [mapDir, mapTgt] of Object.entries(roomExits)) \n\t{\n\t\tlet found = false;\n\t\tfor(let [exitDir, targetNum] of Object.entries(gmcp.room.info.exits)) \n\t\t{\n\t\t\tconst normalizedExDir = map.normalizedDirections[exitDir];\n\t\t\tif (normalizedExDir === map.normalizedDirections[mapDir])\n\t\t\t\tfound = true;\n\t\t}\n\t\tif(!found) \n\t\t{\n\t\t\tconsole.info(\"no match\");\n\t\t\tconsole.info(`Exit from ${roomID} ${mapDir}wards to ${mapTgt} disappeared, removing`);\n\t\t\tmapper.setExit(roomID, -1, mapDir);\n\n\t\t\tdeleteAllExitsFromThisMazeExcept(roomID, niceId);\n\t\t}\n\t}\n\n\t// Things that never change\n\tif (!mapper.getRoomUserData(roomID, \"terrain\")) \n\t{\n\t\t// 1st visit to the room populates this\n\t\tconst roomName = stripColors(gmcp.room.info.name);\n\t\tconsole.info(`Map: new room ${roomID}: ${niceId}: ${roomName}`);\n\t\tmapper.setRoomName(roomID, roomName);\n\t\tmapper.setRoomArea(roomID, areaId);\n\t\tconst terrain = gmcp.room.info.terrain;\n\t\tmapper.setRoomUserData(roomID, \"terrain\", terrain);\n\t\tif (terrain === \"underwater\" || terrain === \"watersurface\" || terrain === \"in_underwater\" || terrain === \"cavelakesurface\")\n\t\t\tmapper.setRoomWeight(roomID, 10);\n\t\telse\n\t\tif (terrain === \"air\" || terrain === \"gap\")\n\t\t\tmapper.setRoomWeight(roomID, 20);\n\n\t\tconst color = cofudlet.map.terrainColors[gmcp.room.info.terrain];\n\t\tif (color !== undefined)  // Might want to consider adding new ones dynamically\n\t\t\tmapper.setRoomEnv(roomID, color);\n\t\telse\n\t\t\tconsole.info(`Previously unseen terrain, need to add color: ${gmcp.room.info.terrain}`);\n\n\t\t// Rooms in randomly connected mazes don't get placed correctly in the\n\t\t// 1st try - walk S of (0,0) and we expect to end up at (0,1), but\n\t\t// could really go anywhere.\n\t\t// Upon entering a new maze room for the 1st time, readjust its coordinates\n\t}\n\n\tmap.lastRoom = map.thisRoom;\n\tmap.thisRoom = roomID;\n\tmapper.centerview(roomID);\n}\n\nfunction isLocked(room, direction) \n{\n\tconst rdSerialized = mapper.getRoomUserData(room, \"exitLocks\");\n\tif (!rdSerialized)\n\t\treturn false;\n\tconst rd = JSON.parse(rdSerialized); // Assuming yajl.to_value is equivalent to JSON.parse\n\t// TODO: check for my level\n\treturn rd[direction] !== undefined;\n}\n\nvar mapon = false;\nvar gmcpinit = false;\nvar saveInterval = null;\nvar lastSaveTime = null;\nvar activitySinceLastSave = false;\n\nfunction openMap()\n{\n\tmapper.createMapper(200,200,200,200);\n\tmapper.loadJsonMap(mapPath);\n\tlastSaveTime = Date.now();\n\tsaveInterval = setInterval(function() \n\t{\n\t\tif (activitySinceLastSave && (Date.now() - lastSaveTime > 60000)) \n\t\t{\n\t\t\tlastSaveTime = Date.now();\n\t\t\tactivitySinceLastSave = false;\n\t\t\tmapper.saveJsonMap(mapPath);\n\t\t\tconsole.info('Map: autosaved');\n\t\t}\n\t}, 10000);\n\tmapon = true;\n\twin.sendGMCP('Room.Info', {});\n\tmapper.recenterOnCurrent();\n\t\tsetTimeout(mapper.updateMap,500);\n}\n\nfunction closeMap()\n{\n\tif(Object.keys(mapper.getAreaTable()).length>0)\n\t{\n\t\tmapper.saveJsonMap(mapPath);\n\t\tmapper.closeMapWidget();\n\t}\n\tclearInterval(saveInterval);\n\tmapon = false;\n}\n\nfunction showHelp()\n{\n\twin.displayText('<FRAME MAPPERHELP SCROLLING=y TITLE=\"Button Bar Help\" ACTION=OPEN FLOATING=close SCROLLING=y TOP=10% LEFT=25% WIDTH=250 HEIGHT=250>');\n\tvar html = '<DEST NAME=MAPPERHELP EOF><FONT COLOR=WHITE>';\n\thtml += 'Right-Click in the Mapper Widget for options.  Use mouse-wheel to zoom in/out.  ';\n\thtml += 'Left click and drag the map with to move it around, or leftclick a room node to move it.  ';\n\thtml += '<BR><BR>Enter /map to toggle map on/off.';\n\twin.displayAt(html,'MAPPERHELP');\n}\n\nwindow.onevent=function(event)\n{\n\t//console.info(event);\n\tif((event.type==='gmcp')&&(mapon))\n\t{\n\t\tvar c = event.command.split('.');\n\t\tvar g = gmcp;\n\t\tfor(i=0;i<c.length-1;i++)\n\t\t{\n\t\t\tg[c[i]] = g[c[i]] || {};\n\t\t\tg=g[c[i]];\n\t\t}\n\t\tg[c[c.length-1]] = event.data || {};\n\t\tif(event.command === 'room.info')\n\t\t{\n\t\t\tonGmcpRoomInfo();\n\t\t\tmapper.recenterOnCurrent();\n\t\t\tmapper.updateMap();\n\t\t\tactivitySinceLastSave = true;\n\t\t}\n\t}\n\telse\n\tif(event.type == 'map')\n\t{\n\t\tif(mapon)\n\t\t\tcloseMap();\n\t\telse\n\t\t\topenMap();\n\t}\n\telse\n\tif(event.data && event.data === 'Help')\n\t\tshowHelp();\n};\n\nfunction startPlugin()\n{\n\twin.sendGMCP('Core.Supports.Add', [\"room.info 1\"]);\n\topenMap();  \n};\n\nsetTimeout(startPlugin,1000);\n"}